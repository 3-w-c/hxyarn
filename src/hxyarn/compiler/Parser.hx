// This file was automatically generated by Caper.
// (http://jonigata.github.io/caper/caper.html)

package src.hxyarn.compiler;

import haxe.ds.Option;

class Stack<T> {
    var stack: Array<T> = [];
    var tmp: Array<T> = [];
    var gap: Int;

    public function new() { this.gap = 0; }

    public function rollbackTmp() {
        this.gap = this.stack.length;
        this.tmp = [];
    }

    public function commitTmp() {
        this.stack.splice(gap, this.stack.length - gap);

        for (e in this.tmp) {
            this.stack.push(e);
        }
        this.tmp = [];
    }
    public function push(f: T): Bool {
        this.tmp.push(f);
        return true;
    }
	   
    public function pop(n: Int) {
        if (this.tmp.length < n) {
            n -= this.tmp.length;
            this.tmp = [];
            this.gap -= n;
        } else {
            this.tmp.splice(-n, n);
        }
    }

    public function top(): T {
        //assert(0 < depth());
        if (0 < this.tmp.length) {
            return this.tmp[this.tmp.length - 1];
        } else {
            return this.stack[this.gap - 1];
        }
    }
	   
    public function getArg(base: Int, index: Int): T {
        var n = tmp.length;
        if (base - index <= n) {
            return this.tmp[n - (base - index)];
        } else {
            return this.stack[this.gap - (base - n) + index];
        }
    }
	   
    public function clear() {
        this.stack = [];
        this.tmp = [];
        this.gap = 0; 
    }
	   
    public function empty(): Bool {
        if (0 < this.tmp.length) {
            return false;
        } else {
            return this.gap == 0;
        }
    }
	   
    public function depth(): Int {
        return this.gap + this.tmp.length;
    }
	   
    public function nth(index: Int): T {
        if (this.gap <= index) {
            return this.tmp[index - this.gap];
        } else {
            return this.stack[index];
        }
    }

    public function setNth(index: Int, t: T) {
        if (this.gap <= index) {
            this.tmp[index - this.gap] = t;
        } else {
            this.stack[index] = t;
        }
    }

    public function swapTopAndSecond() {
        var d = depth();
        //assert(2 <= d);
        var x = nth(d - 1);
        setNth(d - 1, nth(d - 2));
        setNth(d - 2, x);
    }

}

private typedef TableEntry = {
    state: Int,
    gotof: Int,
    handleError: Bool,
};

private typedef StackFrame<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0> = {
    entry: TableEntry,
    value: Dynamic,
    sequenceLength: Int,
};

private typedef Range = {
    begin: Int,
    end: Int,
};

private enum Nonterminal {
    Nonterminal_hashtag;
    Nonterminal_hashtag_seq0;
    Nonterminal_hasttag_begining;
    Nonterminal_line_formatted_text;
    Nonterminal_line_statement;
    Nonterminal_line_statement_ending;
    Nonterminal_statement;
    Nonterminal_statement_seq0;
}
private typedef SemanticAction<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0> = {
    function syntaxError(): Void;
    function stackOverflow(): Void;
    function MakeHashtag(arg0: String): Void;
    function MakeFormatted_Text(arg0: String): Void;
    function MakeLineStatment(arg0: Void, arg1: Array<Void>): Void;
}

class Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0> {

    public function new(sa: SemanticAction<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>){ this.sa = sa; reset(); }

    public function reset() {
        this.failed = false;
        this.accepted = false;
        this.stack = new Stack();
        rollbackTmpStack();
        if (pushStack(0, null)) {
            commitTmpStack();
        } else {
            this.sa.stackOverflow();
            this.failed = true;
        }
    }

    public function post(token: Token, value: Dynamic): Bool {
        rollbackTmpStack();
        this.failed = false;
        while(state_table(stackTop().entry.state, this, token, value)){ }
        if (!this.failed) {
            commitTmpStack();
        } else {
            recover(token, value);
        }
        return this.accepted || this.failed;
    }

    public function accept(): Dynamic {
        //assert(this.accepted);
        if (this.failed) { return null; }
        return this.acceptedValue;
    }

    public function error(): Bool { return this.failed; }


    var accepted: Bool;
    var failed: Bool;
    var acceptedValue: Dynamic;

    var sa: SemanticAction<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>;

    var stack: Stack<StackFrame<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>>;

    function pushStack(stateIndex: Int, v: Dynamic, sl: Int = 0): Bool {
	var f = this.stack.push({
            entry: entry(stateIndex),
            value: v,
            sequenceLength: sl
        });
        //assert(!this.failed);
        if (!f) { 
            this.failed = true;
            this.sa.stackOverflow();
        }
        return f;
    }

    function popStack(n: Int) {
        this.stack.pop(n);
    }

    function stackTop(): StackFrame<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0> {
        return this.stack.top();
    }

    function getArg(base: Int, index: Int): Dynamic {
        return this.stack.getArg(base, index).value;
    }

    function clearStack() {
        this.stack.clear();
    }

    function rollbackTmpStack() {
        this.stack.rollbackTmp();
    }

    function commitTmpStack() {
        this.stack.commitTmp();
    }

    function recover(t: Token, v: Dynamic) {
    }

    function call_nothing(nonterminal: Nonterminal, base: Int): Bool {
        popStack(base);
        var dest_index = gotof_table(stackTop().entry.gotof, nonterminal);
        return pushStack(dest_index, null);
    }

    function call_0_MakeHashtag(nonterminal: Nonterminal, base: Int, argIndex0: Int): Bool {
        var arg0 = getArg(base, argIndex0);
        var r = this.sa.MakeHashtag(arg0);
        popStack(base);
        var dest_index = gotof_table(stackTop().entry.gotof, nonterminal);
        return pushStack(dest_index, r);
    }

    function call_0_MakeFormatted_Text(nonterminal: Nonterminal, base: Int, argIndex0: Int): Bool {
        var arg0 = getArg(base, argIndex0);
        var r = this.sa.MakeFormatted_Text(arg0);
        popStack(base);
        var dest_index = gotof_table(stackTop().entry.gotof, nonterminal);
        return pushStack(dest_index, r);
    }

    function call_0_MakeLineStatment(nonterminal: Nonterminal, base: Int, argIndex0: Int, argIndex1: Int): Bool {
        var arg0 = seqGetArg(base, argIndex0);
        var arg1 = seqGetSequence(base, argIndex1);
        var r = this.sa.MakeLineStatment(arg0, arg1);
        popStack(base);
        var dest_index = gotof_table(stackTop().entry.gotof, nonterminal);
        return pushStack(dest_index, r);
    }

    static function state_0<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case INDENT:
            // shift
            self.pushStack(/*state*/ 4, value);
            return false;
        case TEXT:
            // shift
            self.pushStack(/*state*/ 11, value);
            return false;
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_0(nonterminal: Nonterminal): Int {
        switch(nonterminal) {
        case Nonterminal_line_formatted_text: return 6;
        case Nonterminal_statement: return 1;
        case Nonterminal_line_statement: return 3;
        default: /*assert(0);*/ return -1;
        }
    }

    static function state_1<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case Eof:
            // accept
            self.accepted = true;
            self.acceptedValue = self.getArg(1, 0);
            return false;
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_1(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_2<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case DEDENT:
            // shift
            self.pushStack(/*state*/ 5, value);
            return false;
        case INDENT:
            // shift
            self.pushStack(/*state*/ 4, value);
            return false;
        case TEXT:
            // shift
            self.pushStack(/*state*/ 11, value);
            return false;
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_2(nonterminal: Nonterminal): Int {
        switch(nonterminal) {
        case Nonterminal_line_formatted_text: return 6;
        case Nonterminal_statement: return 19;
        case Nonterminal_line_statement: return 3;
        default: /*assert(0);*/ return -1;
        }
    }

    static function state_3<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case Eof:
            // reduce
            return self.call_nothing(Nonterminal_statement, /*pop*/ 1);
        case DEDENT:
            // reduce
            return self.call_nothing(Nonterminal_statement, /*pop*/ 1);
        case INDENT:
            // reduce
            return self.call_nothing(Nonterminal_statement, /*pop*/ 1);
        case TEXT:
            // reduce
            return self.call_nothing(Nonterminal_statement, /*pop*/ 1);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_3(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_4<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case DEDENT:
            // reduce
            return self.seq_head(Nonterminal_statement_seq0, /*pop*/ 0);
        case INDENT:
            // reduce
            return self.seq_head(Nonterminal_statement_seq0, /*pop*/ 0);
        case TEXT:
            // reduce
            return self.seq_head(Nonterminal_statement_seq0, /*pop*/ 0);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_4(nonterminal: Nonterminal): Int {
        switch(nonterminal) {
        case Nonterminal_statement_seq0: return 2;
        default: /*assert(0);*/ return -1;
        }
    }

    static function state_5<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case Eof:
            // reduce
            return self.call_nothing(Nonterminal_statement, /*pop*/ 3);
        case DEDENT:
            // reduce
            return self.call_nothing(Nonterminal_statement, /*pop*/ 3);
        case INDENT:
            // reduce
            return self.call_nothing(Nonterminal_statement, /*pop*/ 3);
        case TEXT:
            // reduce
            return self.call_nothing(Nonterminal_statement, /*pop*/ 3);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_5(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_6<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case BODY_HASHTAG:
            // reduce
            return self.seq_head(Nonterminal_hashtag_seq0, /*pop*/ 0);
        case HASHTAG:
            // reduce
            return self.seq_head(Nonterminal_hashtag_seq0, /*pop*/ 0);
        case HASHTAG_TAG:
            // reduce
            return self.seq_head(Nonterminal_hashtag_seq0, /*pop*/ 0);
        case TEXT_COMMANDHASHTAG_HASHTAG:
            // reduce
            return self.seq_head(Nonterminal_hashtag_seq0, /*pop*/ 0);
        case TEXT_COMMANDHASHTAG_NEWLINE:
            // reduce
            return self.seq_head(Nonterminal_hashtag_seq0, /*pop*/ 0);
        case TEXT_HASHTAG:
            // reduce
            return self.seq_head(Nonterminal_hashtag_seq0, /*pop*/ 0);
        case TEXT_NEWLINE:
            // reduce
            return self.seq_head(Nonterminal_hashtag_seq0, /*pop*/ 0);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_6(nonterminal: Nonterminal): Int {
        switch(nonterminal) {
        case Nonterminal_hashtag_seq0: return 7;
        default: /*assert(0);*/ return -1;
        }
    }

    static function state_7<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case BODY_HASHTAG:
            // shift
            self.pushStack(/*state*/ 17, value);
            return false;
        case HASHTAG:
            // shift
            self.pushStack(/*state*/ 18, value);
            return false;
        case HASHTAG_TAG:
            // shift
            self.pushStack(/*state*/ 16, value);
            return false;
        case TEXT_COMMANDHASHTAG_HASHTAG:
            // shift
            self.pushStack(/*state*/ 15, value);
            return false;
        case TEXT_COMMANDHASHTAG_NEWLINE:
            // shift
            self.pushStack(/*state*/ 10, value);
            return false;
        case TEXT_HASHTAG:
            // shift
            self.pushStack(/*state*/ 14, value);
            return false;
        case TEXT_NEWLINE:
            // shift
            self.pushStack(/*state*/ 9, value);
            return false;
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_7(nonterminal: Nonterminal): Int {
        switch(nonterminal) {
        case Nonterminal_hashtag: return 20;
        case Nonterminal_hasttag_begining: return 12;
        case Nonterminal_line_statement_ending: return 8;
        default: /*assert(0);*/ return -1;
        }
    }

    static function state_8<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case Eof | DEDENT | INDENT | TEXT:
            // reduce
            return self.call_0_MakeLineStatment(Nonterminal_line_statement, /*pop*/ 3, 0, 1);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_8(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_9<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case Eof:
            // reduce
            return self.call_nothing(Nonterminal_line_statement_ending, /*pop*/ 1);
        case DEDENT:
            // reduce
            return self.call_nothing(Nonterminal_line_statement_ending, /*pop*/ 1);
        case INDENT:
            // reduce
            return self.call_nothing(Nonterminal_line_statement_ending, /*pop*/ 1);
        case TEXT:
            // reduce
            return self.call_nothing(Nonterminal_line_statement_ending, /*pop*/ 1);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_9(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_10<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case Eof:
            // reduce
            return self.call_nothing(Nonterminal_line_statement_ending, /*pop*/ 1);
        case DEDENT:
            // reduce
            return self.call_nothing(Nonterminal_line_statement_ending, /*pop*/ 1);
        case INDENT:
            // reduce
            return self.call_nothing(Nonterminal_line_statement_ending, /*pop*/ 1);
        case TEXT:
            // reduce
            return self.call_nothing(Nonterminal_line_statement_ending, /*pop*/ 1);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_10(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_11<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case BODY_HASHTAG | HASHTAG | HASHTAG_TAG | TEXT_COMMANDHASHTAG_HASHTAG | TEXT_COMMANDHASHTAG_NEWLINE | TEXT_HASHTAG | TEXT_NEWLINE:
            // reduce
            return self.call_0_MakeFormatted_Text(Nonterminal_line_formatted_text, /*pop*/ 1, 0);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_11(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_12<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case HASHTAG_TEXT:
            // shift
            self.pushStack(/*state*/ 13, value);
            return false;
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_12(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_13<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case BODY_HASHTAG | HASHTAG | HASHTAG_TAG | TEXT_COMMANDHASHTAG_HASHTAG | TEXT_COMMANDHASHTAG_NEWLINE | TEXT_HASHTAG | TEXT_NEWLINE:
            // reduce
            return self.call_0_MakeHashtag(Nonterminal_hashtag, /*pop*/ 2, 1);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_13(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_14<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case HASHTAG_TEXT:
            // reduce
            return self.call_nothing(Nonterminal_hasttag_begining, /*pop*/ 1);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_14(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_15<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case HASHTAG_TEXT:
            // reduce
            return self.call_nothing(Nonterminal_hasttag_begining, /*pop*/ 1);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_15(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_16<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case HASHTAG_TEXT:
            // reduce
            return self.call_nothing(Nonterminal_hasttag_begining, /*pop*/ 1);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_16(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_17<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case HASHTAG_TEXT:
            // reduce
            return self.call_nothing(Nonterminal_hasttag_begining, /*pop*/ 1);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_17(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_18<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case HASHTAG_TEXT:
            // reduce
            return self.call_nothing(Nonterminal_hasttag_begining, /*pop*/ 1);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_18(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_19<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case DEDENT:
            // reduce
            return self.seq_trail(Nonterminal_statement_seq0, /*pop*/ 2);
        case INDENT:
            // reduce
            return self.seq_trail(Nonterminal_statement_seq0, /*pop*/ 2);
        case TEXT:
            // reduce
            return self.seq_trail(Nonterminal_statement_seq0, /*pop*/ 2);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_19(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static function state_20<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token: Token, value:  Dynamic): Bool {
        switch(token) {
        case BODY_HASHTAG:
            // reduce
            return self.seq_trail(Nonterminal_hashtag_seq0, /*pop*/ 2);
        case HASHTAG:
            // reduce
            return self.seq_trail(Nonterminal_hashtag_seq0, /*pop*/ 2);
        case HASHTAG_TAG:
            // reduce
            return self.seq_trail(Nonterminal_hashtag_seq0, /*pop*/ 2);
        case TEXT_COMMANDHASHTAG_HASHTAG:
            // reduce
            return self.seq_trail(Nonterminal_hashtag_seq0, /*pop*/ 2);
        case TEXT_COMMANDHASHTAG_NEWLINE:
            // reduce
            return self.seq_trail(Nonterminal_hashtag_seq0, /*pop*/ 2);
        case TEXT_HASHTAG:
            // reduce
            return self.seq_trail(Nonterminal_hashtag_seq0, /*pop*/ 2);
        case TEXT_NEWLINE:
            // reduce
            return self.seq_trail(Nonterminal_hashtag_seq0, /*pop*/ 2);
        default:
            self.sa.syntaxError();
            self.failed = true;
            return false;
        }
    }

    static function gotof_20(nonterminal: Nonterminal): Int {
        //assert(0);
        return -1;
    }

    static var entries = [
        { state: 0, gotof: 0, handleError: false },
        { state: 1, gotof: 1, handleError: false },
        { state: 2, gotof: 2, handleError: false },
        { state: 3, gotof: 3, handleError: false },
        { state: 4, gotof: 4, handleError: false },
        { state: 5, gotof: 5, handleError: false },
        { state: 6, gotof: 6, handleError: false },
        { state: 7, gotof: 7, handleError: false },
        { state: 8, gotof: 8, handleError: false },
        { state: 9, gotof: 9, handleError: false },
        { state: 10, gotof: 10, handleError: false },
        { state: 11, gotof: 11, handleError: false },
        { state: 12, gotof: 12, handleError: false },
        { state: 13, gotof: 13, handleError: false },
        { state: 14, gotof: 14, handleError: false },
        { state: 15, gotof: 15, handleError: false },
        { state: 16, gotof: 16, handleError: false },
        { state: 17, gotof: 17, handleError: false },
        { state: 18, gotof: 18, handleError: false },
        { state: 19, gotof: 19, handleError: false },
        { state: 20, gotof: 20, handleError: false },
    ];

    function entry(n: Int): TableEntry {
        return entries[n];
    }

	static function state_table<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>(index:Int, self:Parser<hashtag, hashtag_seq0, hasttag_begining, line_formatted_text, line_statement, line_statement_ending, statement, statement_seq0>, token:Token, value:Dynamic):Bool {
		return switch index {
			case 0: state_0(self, token, value);
			case 1: state_1(self, token, value);
			case 2: state_2(self, token, value);
			case 3: state_3(self, token, value);
			case 4: state_4(self, token, value);
			case 5: state_5(self, token, value);
			case 6: state_6(self, token, value);
			case 7: state_7(self, token, value);
			case 8: state_8(self, token, value);
			case 9: state_9(self, token, value);
			case 10: state_10(self, token, value);
			case 11: state_11(self, token, value);
			case 12: state_12(self, token, value);
			case 13: state_13(self, token, value);
			case 14: state_14(self, token, value);
			case 15: state_15(self, token, value);
			case 16: state_16(self, token, value);
			case 17: state_17(self, token, value);
			case 18: state_18(self, token, value);
			case 19: state_19(self, token, value);
			case 20: state_20(self, token, value);
			case _: throw "state_table faild.";
		}
	}
	static function gotof_table(index:Int, nonterminal: Nonterminal):Int {
		return switch index {
			case 0: gotof_0(nonterminal);
			case 1: gotof_1(nonterminal);
			case 2: gotof_2(nonterminal);
			case 3: gotof_3(nonterminal);
			case 4: gotof_4(nonterminal);
			case 5: gotof_5(nonterminal);
			case 6: gotof_6(nonterminal);
			case 7: gotof_7(nonterminal);
			case 8: gotof_8(nonterminal);
			case 9: gotof_9(nonterminal);
			case 10: gotof_10(nonterminal);
			case 11: gotof_11(nonterminal);
			case 12: gotof_12(nonterminal);
			case 13: gotof_13(nonterminal);
			case 14: gotof_14(nonterminal);
			case 15: gotof_15(nonterminal);
			case 16: gotof_16(nonterminal);
			case 17: gotof_17(nonterminal);
			case 18: gotof_18(nonterminal);
			case 19: gotof_19(nonterminal);
			case 20: gotof_20(nonterminal);
			case _: throw "gotof_table faild.";
		}
	}
}

